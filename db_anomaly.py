#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Dec 10 15:22:30 2020@author: alejandrosalinas"""import pandas as pdimport matplotlib.pyplot as pltimport numpy as npdef show_data():    columnas=[0,1]    nombres_columnas = ["X","Y"]    df = pd.read_csv("./data/zahn - zahn.csv",names=nombres_columnas, usecols=columnas)    datos = df.to_numpy()    df = pd.read_csv("./data/zahn - zahn.csv",names=nombres_columnas, usecols=columnas)    datos = df.to_numpy()    plt.scatter(df["X"],df["Y"])    plt.show()    return datosdef matrizDistancias(array:list,distance:str):    t = len(array)    matriz = np.zeros((t,t))    for i in range(0,t-1):        for j in range(i+1,t):            if distance == "euclidean":                matriz[i][j] = euclidean_distance(array[i],array[j])            elif distance == "city-block":                matriz[i][j] = city_block_distance(array[i],array[j])            matriz[j][i] = matriz[i][j]    return matrizdef euclidean_distance(p0,p1):    return np.sqrt(np.sum((p0 - p1)**2))def city_block_distance(p0,p1):    return np.sum(np.abs(p0 - p1))def detect_db_outliers(pct,dmin,array,distancias):    array_anom = array.copy()    nueva_col = np.zeros((len(array),1))    array_anom = np.append(array_anom,nueva_col,axis=1)    pLimite = len(array) * (1 - pct)    i = 0    for vectorD in distancias:        menores = vectorD[vectorD <= dmin]        array_anom[i][2] = 1 if ((len(menores) - 1 ) <= pLimite) else 0        i+=1    return array_anomdef find_dataset_diameter(distances:list, diameters:list):    for i in distances:        diameters.append((max(i)))    diameters = max(diameters)    return diametersdef generate_min_distances_vector(diam_euclidean:float, diam_manh:float, R1:list, R2:list):    for j in range(1,11):        k = diam_euclidean/10.0           k2 = diam_manh/10.0        R1.append(j*k)        R2.append(j*k2)    return R1, R2def graphData(data:list, r:float, pct:float, file_index:str,dist: str):    df = pd.DataFrame(data)    t = df[2].to_numpy()    colors = []    if dist == "euclidean":        for j in t:            if(j== 1.0):                colors.append("lightpink")            else:                colors.append("gold")        file = "file"+str(file_index)        file2 = "./results/"+file+".png"    elif dist == "city-block":        for j in t:            if(j== 1.0):                colors.append("mediumaquamarine")            else:                colors.append("tomato")        file = "file"+str(file_index)        file2 = "./results2/"+file+".png"        x = df[0]    y = df[1]    title  = "R: ",r,"PCT: ",pct    plt.title(title)    plt.scatter(x,y, c=colors)    plt.savefig(file2)     plt.show()def detect_outliers(R:list ,datos:list ,distances:list, dist: str):    count = 0    for i in R:        for j in range(1,21):            outliers_loop = detect_db_outliers(j/100,i,datos,distances)            graphData(outliers_loop,i,j/100,count,dist)            count +=1def main():     diam_eucl = []    diam_manh = []    r_eucl = []    r_manh = []    """    Reading data    """    data = show_data()    """    Build distance (euclidean, city-block) matrix    """    m_dist = matrizDistancias(data,"euclidean")    m_dist_manh = matrizDistancias(data,"city-block")    """    Find dataset Diameters    """     diam_eucl = find_dataset_diameter(m_dist,diam_eucl)    diam_dist_manh = find_dataset_diameter(m_dist_manh,diam_manh)    """    Generate Minimum Distances Vector    """    r_eucl,r_manh = generate_min_distances_vector(diam_eucl,diam_dist_manh,r_eucl,r_manh)    """    Find Distance Based(DB) Outliers    """    detect_outliers(r_eucl,data,m_dist,"euclidean")    #Yellow Points are DB Anomalies    detect_outliers(r_manh,data,m_dist_manh,"city-block")    #Aquablue Points are DB Anomalies        print("Finished")if __name__ == "__main__":      main() 